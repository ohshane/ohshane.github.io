<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Shane Oh">
<meta name="dcterms.date" content="2023-04-14">

<title>Binary Heap – Shane</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../image/favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<link rel="apple-touch-icon" href="image/apple-touch-icon.png">
<link rel="apple-touch-startup-image" href="image/profile.jpg">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<script src="../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
<meta property="og:title" content="Binary Heap – Shane">
<meta property="og:description" content="For better priority queuing">
<meta property="og:site_name" content="Shane">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../image/logo.png" alt="" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#represent-a-binary-tree-in-an-array" id="toc-represent-a-binary-tree-in-an-array" class="nav-link active" data-scroll-target="#represent-a-binary-tree-in-an-array">Represent a binary tree in an array</a></li>
  <li><a href="#heap-property" id="toc-heap-property" class="nav-link" data-scroll-target="#heap-property">Heap property</a></li>
  <li><a href="#heapify" id="toc-heapify" class="nav-link" data-scroll-target="#heapify">Heapify</a></li>
  <li><a href="#build-heap" id="toc-build-heap" class="nav-link" data-scroll-target="#build-heap">Build heap</a></li>
  <li><a href="#inserting-and-popping-elements-in-the-queue" id="toc-inserting-and-popping-elements-in-the-queue" class="nav-link" data-scroll-target="#inserting-and-popping-elements-in-the-queue">Inserting and popping elements in the queue</a></li>
  <li><a href="#heap-sort" id="toc-heap-sort" class="nav-link" data-scroll-target="#heap-sort">Heap sort</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Binary Heap</h1>
<p class="subtitle lead">For better priority queuing</p>
  <div class="quarto-categories">
    <div class="quarto-category">Algorithms</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Shane Oh </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 14, 2023</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Check out a <a href="https://youtu.be/HqPJF2L5h9U?si=i0OFnjbWOS4cKNoU">video</a> by Abdul Bari.</p>
<section id="represent-a-binary-tree-in-an-array" class="level2">
<h2 class="anchored" data-anchor-id="represent-a-binary-tree-in-an-array">Represent a binary tree in an array</h2>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TB
  A(1: A) --- B(2: B)
  A --- C(3: C)
  B --- D(4: D)
  B --- E(5: E)
  C --- F(6: F)
  C --- G(7: G)
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<div id="btree-in-array">
  <div class="item"></div>
  <div class="item box">A</div>
  <div class="item box">B</div>
  <div class="item box">C</div>
  <div class="item box">D</div>
  <div class="item box">E</div>
  <div class="item box">F</div>
  <div class="item box">G</div>

  <div class="item">idx</div>
  <div class="item">1</div>
  <div class="item">2</div>
  <div class="item">3</div>
  <div class="item">4</div>
  <div class="item">5</div>
  <div class="item">6</div>
  <div class="item">7</div>
</div>

<style scoped="">
  #btree-in-array {
    font-family: monospace;
    font-size: 0.9rem;
    display: grid;
    justify-content: center;
    grid-template-columns: repeat(8, 2rem);
    grid-template-rows: repeat(2, 2rem);
    gap: 0 10px;
  }
  .item {
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .box {
    border: none;
    background: var(--mermaid-node-bg-color);
    color: var(--mermaid-label-fg-color);
    border: 1px solid black;
  }
</style>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>To represent a binary tree in an array, you can follow these rules:</p>
<ul>
<li>If the root of the tree is at index <code>1</code> &lt;- easier to remember</li>
<li>For a node at index <span class="math inline">\(i\)</span>:
<ul>
<li>The left child is at index <span class="math inline">\(2i\)</span>.</li>
<li>The right child is at index <span class="math inline">\(2i+1\)</span>.</li>
<li>The parent is at index <span class="math inline">\(\lfloor \frac{i}{2} \rfloor\)</span>.</li>
</ul></li>
<li>If the root of the tree is at index <code>0</code> &lt;- when implementing</li>
<li>For a node at index <span class="math inline">\(i\)</span>:
<ul>
<li>The left child is at index <span class="math inline">\(2i+1\)</span>.</li>
<li>The right child is at index <span class="math inline">\(2i+2\)</span>.</li>
<li>The parent is at index <span class="math inline">\(\lfloor \frac{i - 1}{2} \rfloor\)</span>.</li>
</ul></li>
</ul>
</div>
</div>
<p>The definition of an (almost) complete binary tree becomes clearer when we represent tree structure as an array. <em>We should not allow any null values between the elements.</em></p>
<p>Now you may be thinking about the difference between binary trees and heaps. Actually, while all heaps are binary trees, not all binary trees are heaps. You must fulfill the <strong>heap property</strong>. So what is it?</p>
</section>
<section id="heap-property" class="level2">
<h2 class="anchored" data-anchor-id="heap-property">Heap property</h2>
<div id="venn">
  <div class="set set-1">
    Tree
    <div class="set set-2">
      Binary tree
      <div class="set set-3">
        Almost complete binary tree
        <div class="set set-4">
          Heap
          <div class="label">
            Min-heap / Max-heap
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
  #venn {
    /* border: 1px solid black; */
    box-sizing: content-box;
    margin: 20px;
  }

  #venn > * {
    potision: relative
    box-sizing: border-box;
    font-size: 0.9rem;
  }

  .set {
    margin: 10px;
    padding: 2px;
    border-radius: 10px;
    border: 1px solid black;
    text-align: center;
  }

  .set-1 {
    margin: 0 auto;
    height: 100%;
    width: 80%;
    max-width: 400px;
  }

  .set-4 {
    border-radius: 50%;
    background: #e9f2fc;
  }

  .label {
    margin: 20px 0 35px 0;
  }
</style>
<p>The heap property dictates the relationship between a parent node and its children in a binary tree. It can be defined in two ways, leading to two different types of heaps:</p>
<ul>
<li><p>Min-heap property <span class="math display">\[A[\lfloor \frac{i}{2} \rfloor] \leq A[i]\]</span></p></li>
<li><p>Max-heap property <span class="math display">\[A[\lfloor \frac{i}{2} \rfloor] \geq A[i]\]</span></p></li>
</ul>
<p>If you have an array <span class="math inline">\(A\)</span> with no null values between elements, you are already satisfying the almost complete binary tree property and are halfway ready to be a heap structure. How cool is that!</p>
<p>The remaining half of the process is called <strong>heapifying</strong>.</p>
</section>
<section id="heapify" class="level2">
<h2 class="anchored" data-anchor-id="heapify">Heapify</h2>
<p>Check out the <a href="https://youtu.be/cuL8gXCSA58?si=iFOBARlCficaix_o">video</a> by Techdose helps!</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TB
  A(  ) -.- 10
  A(  ) -.- B(  )
  10 --- 8
  10 --- 12
  8 -.- C(  )
  8 -.- D(  )
  12 -.- E(  )
  12 -.- F(  )
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>Let’s examine the tree above (with node <code>10</code> as root). Assert that the subtrees under node <code>10</code> are max-heaps. By recursively sifting down (similar to bubble sorting) on node <code>10</code>, the entire tree will eventually become a max-heap.</p>
<p>The time complexity of heapifying is the same as the height of the heapifying index. Thankfully, the tree is balanced from the very start, which makes it <span class="math inline">\(O(\log n)\)</span>. Obvious, right?</p>
</section>
<section id="build-heap" class="level2">
<h2 class="anchored" data-anchor-id="build-heap">Build heap</h2>
<p>Thanks again for the <a href="https://youtu.be/VkKmmwzfIG4?si=Q0QJnGykFcj3wkRR">video</a>!</p>
<p>Let’s transform an arbitrary array <span class="math inline">\(A\)</span> into a <strong>heap</strong> using the <strong>build-heap</strong> process.</p>
<p><span class="math display">\[\begin{align*}
  A &amp;\quad
  \begin{bmatrix}
    2 &amp; 12 &amp; 5 &amp; 15 &amp; 16 &amp; 2 &amp; 6 &amp; 9 &amp; 1 &amp; 4
  \end{bmatrix} \\

  \text{Max-Heapify}(A) &amp;\quad
  \begin{bmatrix}
    16 &amp; 15 &amp; 6 &amp; 9 &amp; 12 &amp; 2 &amp; 5 &amp; 2 &amp; 1 &amp; 4
  \end{bmatrix}
\end{align*}\]</span></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Heapifying and heap sorting
</div>
</div>
<div class="callout-body-container callout-body">
<p>Heapifying and heap sorting are a bit different.</p>
<p>It is guaranteed that the first element (or the root) of a heap is the minimum or maximum value (which is why a heap can be used as a priority queue), but the rest is not yet sorted in a single sequence (although the path from the root to the leaf is sorted).</p>
<p>Think of heapifying as an intermediate stage before heap sorting.</p>
</div>
</div>
<p>So, do we start heapifying from the top or the bottom?</p>
<p>The answer is from the bottom. Take a look at the implemented code.</p>
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>maxheapify.go</strong></pre>
</div>
<div class="sourceCode" id="annotated-cell-1" data-filename="maxheapify.go"><pre class="sourceCode go code-annotation-code code-with-copy code-annotated"><code class="sourceCode go"><span id="annotated-cell-1-1"><a href="#annotated-cell-1-1" aria-hidden="true" tabindex="-1"></a><span class="co">// MaxHeap constructs a max-heap from an unordered array</span></span>
<span id="annotated-cell-1-2"><a href="#annotated-cell-1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// `i` starts from 0 in this code</span></span>
<span id="annotated-cell-1-3"><a href="#annotated-cell-1-3" aria-hidden="true" tabindex="-1"></a><span class="co">// We are basically bubble sorting from node `i` to the leaf node</span></span>
<span id="annotated-cell-1-4"><a href="#annotated-cell-1-4" aria-hidden="true" tabindex="-1"></a><span class="co">// while iterating `i` from n to 0.</span></span>
<span id="annotated-cell-1-5"><a href="#annotated-cell-1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> BuildMaxHeap<span class="op">(</span>arr <span class="op">[]</span><span class="dt">int</span><span class="op">,</span> n <span class="dt">int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-1-6"><a href="#annotated-cell-1-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Start from the last non-leaf node and heapify each node</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-1-7" class="code-annotation-target"><a href="#annotated-cell-1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">:=</span> n<span class="op">/</span><span class="dv">2</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--</span> <span class="op">{</span></span>
<span id="annotated-cell-1-8"><a href="#annotated-cell-1-8" aria-hidden="true" tabindex="-1"></a>        MaxHeapify<span class="op">(</span>arr<span class="op">,</span> n<span class="op">,</span> i<span class="op">)</span></span>
<span id="annotated-cell-1-9"><a href="#annotated-cell-1-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-1-10"><a href="#annotated-cell-1-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="annotated-cell-1-11"><a href="#annotated-cell-1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-1-12"><a href="#annotated-cell-1-12" aria-hidden="true" tabindex="-1"></a><span class="co">// MaxHeapify ensures the subtree rooted at index i is a max-heap</span></span>
<span id="annotated-cell-1-13"><a href="#annotated-cell-1-13" aria-hidden="true" tabindex="-1"></a><span class="co">//      i</span></span>
<span id="annotated-cell-1-14"><a href="#annotated-cell-1-14" aria-hidden="true" tabindex="-1"></a><span class="co">//    /   \</span></span>
<span id="annotated-cell-1-15"><a href="#annotated-cell-1-15" aria-hidden="true" tabindex="-1"></a><span class="co">// left   right</span></span>
<span id="annotated-cell-1-16"><a href="#annotated-cell-1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> MaxHeapify<span class="op">(</span>arr <span class="op">[]</span><span class="dt">int</span><span class="op">,</span> n<span class="op">,</span> i <span class="dt">int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="annotated-cell-1-17"><a href="#annotated-cell-1-17" aria-hidden="true" tabindex="-1"></a>    largest <span class="op">:=</span> i       <span class="co">// Initialize largest as root</span></span>
<span id="annotated-cell-1-18"><a href="#annotated-cell-1-18" aria-hidden="true" tabindex="-1"></a>    left <span class="op">:=</span> <span class="dv">2</span><span class="op">*</span>i <span class="op">+</span> <span class="dv">1</span>    <span class="co">// left child index</span></span>
<span id="annotated-cell-1-19"><a href="#annotated-cell-1-19" aria-hidden="true" tabindex="-1"></a>    right <span class="op">:=</span> <span class="dv">2</span><span class="op">*</span>i <span class="op">+</span> <span class="dv">2</span>   <span class="co">// right child index</span></span>
<span id="annotated-cell-1-20"><a href="#annotated-cell-1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-1-21"><a href="#annotated-cell-1-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If left child is larger than root</span></span>
<span id="annotated-cell-1-22"><a href="#annotated-cell-1-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> left <span class="op">&lt;</span> n <span class="op">&amp;&amp;</span> arr<span class="op">[</span>left<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>largest<span class="op">]</span> <span class="op">{</span></span>
<span id="annotated-cell-1-23"><a href="#annotated-cell-1-23" aria-hidden="true" tabindex="-1"></a>        largest <span class="op">=</span> left</span>
<span id="annotated-cell-1-24"><a href="#annotated-cell-1-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-1-25"><a href="#annotated-cell-1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-1-26"><a href="#annotated-cell-1-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If right child is larger than the largest so far</span></span>
<span id="annotated-cell-1-27"><a href="#annotated-cell-1-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> right <span class="op">&lt;</span> n <span class="op">&amp;&amp;</span> arr<span class="op">[</span>right<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>largest<span class="op">]</span> <span class="op">{</span></span>
<span id="annotated-cell-1-28"><a href="#annotated-cell-1-28" aria-hidden="true" tabindex="-1"></a>        largest <span class="op">=</span> right</span>
<span id="annotated-cell-1-29"><a href="#annotated-cell-1-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-1-30"><a href="#annotated-cell-1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-1-31"><a href="#annotated-cell-1-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If largest is not root</span></span>
<span id="annotated-cell-1-32"><a href="#annotated-cell-1-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> largest <span class="op">!=</span> i <span class="op">{</span></span>
<span id="annotated-cell-1-33"><a href="#annotated-cell-1-33" aria-hidden="true" tabindex="-1"></a>        arr<span class="op">[</span>i<span class="op">],</span> arr<span class="op">[</span>largest<span class="op">]</span> <span class="op">=</span> arr<span class="op">[</span>largest<span class="op">],</span> arr<span class="op">[</span>i<span class="op">]</span>  <span class="co">// Swap</span></span>
<span id="annotated-cell-1-34"><a href="#annotated-cell-1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-1-35"><a href="#annotated-cell-1-35" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Recursively heapify the affected subtree</span></span>
<span id="annotated-cell-1-36"><a href="#annotated-cell-1-36" aria-hidden="true" tabindex="-1"></a>        MaxHeapify<span class="op">(</span>arr<span class="op">,</span> n<span class="op">,</span> largest<span class="op">)</span></span>
<span id="annotated-cell-1-37"><a href="#annotated-cell-1-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-1-38"><a href="#annotated-cell-1-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-1" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="7" data-code-annotation="1">The <code>for</code> loop can be iterated from <code>n</code> to <code>0</code>. However, since half of the elements (which are leaf nodes) are already part of a heap, we can start from the node that is not a leaf.</span>
</dd>
</dl>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
What is the range of leaf nodes?
</div>
</div>
<div class="callout-body-container callout-body">
<p>The parent of the last element can be considered the last node that is not a leaf node.</p>
<p><span class="math display">\[
A[\lfloor \dfrac{n}{2} \rfloor + 1:n]
\]</span></p>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Levels and heights of binary trees
</div>
</div>
<div class="callout-body-container callout-body">
<pre><code>Level 0                  1                  Height 3
                        / \                         
Level 1          2               3          Height 2
                / \             / \                 
Level 2      4       5       6       7      Height 1
            / \     / \     / \     / \             
Level 3    8   9  10   11 12   13 14   15   Height 0</code></pre>
<p>Try to imagine a complete binary tree with a large number of levels. Pick any level you desire in between and set it as <span class="math inline">\(l\)</span>.</p>
<ul>
<li>The <strong>indices</strong> of the first elements at each level are <span class="math inline">\(2^l\)</span> and the <strong>level</strong> of a certain index is <span class="math inline">\(\lfloor \log_{2} i \rfloor\)</span>.</li>
<li>There are <span class="math inline">\(2^{l}-1\)</span> nodes in the whole tree just before level <span class="math inline">\(l\)</span>.</li>
<li>There are <span class="math inline">\(2^{l}\)</span> nodes at level <span class="math inline">\(l\)</span>.</li>
<li>There are <span class="math inline">\(2^{l+1}\)</span> nodes at the next level, <span class="math inline">\(l+1\)</span>, which is twice as many.</li>
<li>At <strong>height</strong> <span class="math inline">\(h\)</span>, there are a maximum of <span class="math inline">\(\lceil \frac{N}{2^{h+1}} \rceil\)</span> nodes.</li>
</ul>
</div>
</div>
<p>The nodes at height <span class="math inline">\(h\)</span> needs to be heapified by sifting down <span class="math inline">\(h\)</span> times and there are <span class="math inline">\(\lceil \frac{N}{2^{h+1}} \rceil\)</span> nodes max at each height <span class="math inline">\(h\)</span> which makes,</p>
<p><span class="math display">\[
\begin{align*}
\sum_{h=0}^{\lfloor \log_2 N \rfloor} \lceil \dfrac{N}{2^{h+1}} \rceil O(h)
&amp;&lt; O \left( \sum_{h=0}^{\infty} \dfrac{N}{2^{h+1}} C h \right) \\
&amp;= O \left( \dfrac{CN}{2} \sum_{h=0}^{\infty} \dfrac{h}{2^{h}} \right) \\
&amp;= O \left( \dfrac{CN}{2} 2 \right) \\
&amp;= O(N)
\end{align*}
\]</span></p>
<p>The talor series is useful when explaining this.</p>
<p>Congratulations! You now have a beautiful max-heap ready. Let’s utilize this as a priority queue.</p>
</section>
<section id="inserting-and-popping-elements-in-the-queue" class="level2">
<h2 class="anchored" data-anchor-id="inserting-and-popping-elements-in-the-queue">Inserting and popping elements in the queue</h2>
<p>Insert from the <strong>right</strong>, pop from the <strong>left</strong>.</p>
<p>Inserting from the right helps us to maintain the almost complete binary tree property, but the max-heap property is broken.</p>
<p><span class="math display">\[\begin{align*}
  A_\text{max-heap} &amp;\quad
  \begin{bmatrix}
    16 &amp; 15 &amp; 6 &amp; 9 &amp; 12 &amp; 2 &amp; 5 &amp; 2 &amp; 1 &amp; 4
  \end{bmatrix}\\

  A_\text{broken-max-heap} &amp;\quad
  \begin{bmatrix}
    16 &amp; 15 &amp; 6 &amp; 9 &amp; 12 &amp; 2 &amp; 5 &amp; 2 &amp; 1 &amp; 4 &amp; 100
  \end{bmatrix}\\

  &amp;\quad
  \begin{bmatrix}
    16 &amp; 15 &amp; 6 &amp; 9 &amp; 100 &amp; 2 &amp; 5 &amp; 2 &amp; 1 &amp; 4 &amp; 12
  \end{bmatrix}\\

  &amp;\quad
  \begin{bmatrix}
    16 &amp; 100 &amp; 6 &amp; 9 &amp; 15 &amp; 2 &amp; 5 &amp; 2 &amp; 1 &amp; 4 &amp; 12
  \end{bmatrix}\\

  A_\text{max-heap} &amp;\quad
  \begin{bmatrix}
    100 &amp; 16 &amp; 6 &amp; 9 &amp; 15 &amp; 2 &amp; 5 &amp; 2 &amp; 1 &amp; 4 &amp; 12
  \end{bmatrix}\\
\end{align*}\]</span></p>
<p>The solution is to check the integrity from the inserted leaf node to the root. Simply compare with the parent node and propagate upward to the top. In the array representation, it seems like hopping to the left for <span class="math inline">\(\log n\)</span> times.</p>
<p>Popping is done by removing the root and replacing it with the last leaf node. To preserve the max-heap property, we propagate downward from the root to the bottom.</p>
<p><span class="math display">\[\begin{align*}
  A_\text{max-heap} &amp;\quad
  \begin{bmatrix}
    100 &amp; 16 &amp; 6 &amp; 9 &amp; 15 &amp; 2 &amp; 5 &amp; 2 &amp; 1 &amp; 4 &amp; 12
  \end{bmatrix}\\

  A_\text{broken-max-heap} &amp;\quad
  \begin{bmatrix}
    12 &amp; 16 &amp; 6 &amp; 9 &amp; 15 &amp; 2 &amp; 5 &amp; 2 &amp; 1 &amp; 4
  \end{bmatrix}\\

  &amp;\quad
  \begin{bmatrix}
    16 &amp; 12 &amp; 6 &amp; 9 &amp; 15 &amp; 2 &amp; 5 &amp; 2 &amp; 1 &amp; 4
  \end{bmatrix}\\

  A_\text{max-heap} &amp;\quad
  \begin{bmatrix}
    16 &amp; 15 &amp; 6 &amp; 9 &amp; 12 &amp; 2 &amp; 5 &amp; 2 &amp; 1 &amp; 4
  \end{bmatrix}\\

\end{align*}\]</span></p>
<p>Notice that the root node always holds the maximum value of the entire tree. This characteristic enables <strong>sorting</strong>; you simply keep popping the root until the heap is empty.</p>
</section>
<section id="heap-sort" class="level2">
<h2 class="anchored" data-anchor-id="heap-sort">Heap sort</h2>
<p>Why do we need to create a dedicated paragraph for sorting when it is so straightforward? There is a fun little idea behind heap sorting in an array that makes it more elegant.</p>
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>heapsort.go</strong></pre>
</div>
<div class="sourceCode" id="annotated-cell-2" data-filename="heapsort.go"><pre class="sourceCode go code-annotation-code code-with-copy code-annotated"><code class="sourceCode go"><span id="annotated-cell-2-1"><a href="#annotated-cell-2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> HeapSort<span class="op">(</span>arr <span class="op">[]</span><span class="dt">int</span><span class="op">,</span> n <span class="dt">int</span><span class="op">)</span> <span class="op">{</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-2-2" class="code-annotation-target"><a href="#annotated-cell-2-2" aria-hidden="true" tabindex="-1"></a>    BuildMaxHeap<span class="op">(</span>arr<span class="op">)</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-2-3" class="code-annotation-target"><a href="#annotated-cell-2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> m <span class="op">:=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> m <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> m<span class="op">--</span> <span class="op">{</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-2-4" class="code-annotation-target"><a href="#annotated-cell-2-4" aria-hidden="true" tabindex="-1"></a>        arr<span class="op">[</span><span class="dv">0</span><span class="op">],</span> arr<span class="op">[</span>m<span class="op">]</span> <span class="op">=</span> arr<span class="op">[</span>m<span class="op">],</span> arr<span class="op">[</span><span class="dv">0</span><span class="op">]</span></span>
<span id="annotated-cell-2-5"><a href="#annotated-cell-2-5" aria-hidden="true" tabindex="-1"></a>        MaxHeapify<span class="op">(</span>arr<span class="op">,</span> m<span class="op">,</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="annotated-cell-2-6"><a href="#annotated-cell-2-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="annotated-cell-2-7"><a href="#annotated-cell-2-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-2" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="2" data-code-annotation="1">First, create a max-heap.</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="3" data-code-annotation="2">Instead of popping and stacking the elements into a new empty array, we utilize the original array. After popping, there is a spare index because the size of the heap is reduced.</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="4,5" data-code-annotation="3">By marking the end of the max-heap with <code>m</code>, we can swap the root value with the leaf at the very end. The popped value will be stacked from the end of the array, and eventually, the array will become a sorted array in ascending order.</span>
</dd>
</dl>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/ohshane\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>