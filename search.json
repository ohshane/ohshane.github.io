[
  {
    "objectID": "posts/Git.html",
    "href": "posts/Git.html",
    "title": "Local Git Commands",
    "section": "",
    "text": "Thanks Cottle for creating this educational tool. Ever thought of Git graphs as linked lists? Here is a great explanation.\nFirst things first,"
  },
  {
    "objectID": "posts/Git.html#git-commit",
    "href": "posts/Git.html#git-commit",
    "title": "Local Git Commands",
    "section": "git commit",
    "text": "git commit\nThis creates a new commit C1, which references where it was based off of — in this case, a C0 which is a initial commit becomes the parent.\ngit commit\n\n\n\n\n\n\n\n\n\n\nflowchart TB\n  main:::pointer -.-&gt; C0:::commit\n  HEAD:::pointer -.-&gt; main\n  classDef commit fill: #abc, color: #000\n  classDef pointer fill: #fff, color #000, font: #000\n\n\n\n\n\n\n\n\n\n\n\nflowchart TB\n  C1:::commit --&gt; C0:::commit\n  main:::pointer -.-&gt; C1\n  HEAD:::pointer -.-&gt; main\n  classDef commit fill: #abc, color: #000\n  classDef pointer fill: #fff, color #000, font: #000"
  },
  {
    "objectID": "posts/Git.html#git-branch",
    "href": "posts/Git.html#git-branch",
    "title": "Local Git Commands",
    "section": "git branch",
    "text": "git branch\nBranches is Git are simply pointers to a specific commit – nothing more. This is why many Git enthusiasts chant the mantra\n\nbranch early, and branch often.\n\nWhen we start mixing branches (pointers) and commits, we will see how these two features combine. For now, just remember that a branch essentially says\n\nI want to include the work of this commit and all parent commits.\n\ngit checkout main\ngit branch dev\n\n\n\n\n\n\n\n\n\n\nflowchart TB\n  C1:::commit --&gt; C0:::commit\n  main:::pointer -.-&gt; C1\n  HEAD:::pointer -.-&gt; main\n  classDef commit fill: #abc, color: #000\n  classDef pointer fill: #fff, color #000, font: #000\n\n\n\n\n\n\n\n\n\n\n\nflowchart TB\n  C1:::commit --&gt; C0:::commit\n  main:::pointer -.-&gt; C1\n  dev:::pointer -.-&gt; C1\n  HEAD:::pointer -.-&gt; main\n  classDef commit fill: #abc, color: #000\n  classDef pointer fill: #fff, color #000, font: #000\n\n\n\n\n\n\n\n\ngit checkout main\ngit checkout -b dev\ngit checkout main\ngit switch -c dev\n\n\n\n\n\n\n\n\n\n\nflowchart TB\n  C1:::commit --&gt; C0:::commit\n  main:::pointer -.-&gt; C1\n  HEAD:::pointer -.-&gt; main\n  classDef commit fill: #abc, color: #000\n  classDef pointer fill: #fff, color #000, font: #000\n\n\n\n\n\n\n\n\n\n\n\nflowchart TB\n  C1:::commit --&gt; C0:::commit\n  main:::pointer -.-&gt; C1\n  dev:::pointer -.-&gt; C1\n  HEAD:::pointer -.-&gt; dev\n  classDef commit fill: #abc, color: #000\n  classDef pointer fill: #fff, color #000, font: #000"
  },
  {
    "objectID": "posts/Git.html#git-merge",
    "href": "posts/Git.html#git-merge",
    "title": "Local Git Commands",
    "section": "git merge",
    "text": "git merge\nmerge command eventually creates a special commit which has two unique parents. A commit with two parents essentially means\n\nI want to include all the work from both parents, and the set of all their parents.\n\ngit checkout main\n1git merge dev\ngit checkout dev\n2git merge main\n\n1\n\nThe command merges dev branch into the current main branch. This leaves the dev branch (pointer) behind.\n\n2\n\nWe don’t need to derive the work from both the main and dev parents again because the dev graph is a subgraph of the main graph. Instead, we can simply move the dev pointer to match the position of the main pointer. This is also called fast forward.\n\n\n\n\n\n\n\n\n\n\n\n\nflowchart TB\n  C1:::commit --&gt; C0:::commit\n  C2:::commit --&gt; C1:::commit\n  C3:::commit --&gt; C1:::commit\n  main:::pointer -.-&gt; C2\n  dev:::pointer -.-&gt; C3\n  HEAD:::pointer -.-&gt; main\n  classDef commit fill: #abc, color: #000\n  classDef pointer fill: #fff, color #000, font: #000\n\n\n\n\n\n\n\n\n\n\n\nflowchart TB\n  C1:::commit --&gt; C0:::commit\n  C2:::commit --&gt; C1:::commit\n  C3:::commit --&gt; C1:::commit\n  C4:::commit --&gt; C2:::commit\n  C4:::commit --&gt; C3:::commit\n\n  main:::pointer -.-&gt; C4\n  dev:::pointer -.-&gt; C3\n  HEAD:::pointer -.-&gt; main\n  classDef commit fill: #abc, color: #000\n  classDef pointer fill: #fff, color #000, font: #000\n\n\n\n\n\n\n\n\n\n\n\nflowchart TB\n  C1:::commit --&gt; C0:::commit\n  C2:::commit --&gt; C1:::commit\n  C3:::commit --&gt; C1:::commit\n  C4:::commit --&gt; C2:::commit\n  C4:::commit --&gt; C3:::commit\n\n  main:::pointer -.-&gt; C4\n  dev:::pointer -.-&gt; C3\n  HEAD:::pointer -.-&gt; dev\n  classDef commit fill: #abc, color: #000\n  classDef pointer fill: #fff, color #000, font: #000\n\n\n\n\n\n\n\n\n\n\n\nflowchart TB\n  C1:::commit --&gt; C0:::commit\n  C2:::commit --&gt; C1:::commit\n  C3:::commit --&gt; C1:::commit\n  C4:::commit --&gt; C2:::commit\n  C4:::commit --&gt; C3:::commit\n\n  main:::pointer -.-&gt; C4\n  dev:::pointer -.-&gt; C4\n  HEAD:::pointer -.-&gt; dev\n  classDef commit fill: #abc, color: #000\n  classDef pointer fill: #fff, color #000, font: #000"
  },
  {
    "objectID": "posts/Git.html#git-rebase",
    "href": "posts/Git.html#git-rebase",
    "title": "Local Git Commands",
    "section": "git rebase",
    "text": "git rebase\nrebase copies the commits and stack them on somewhere else.\n\n\n\n\n\n\nNote\n\n\n\nThe position of the HEAD pointer is different when merging and rebasing.\ngit checkout main # &lt;- HEAD\ngit merge dev\ngit checkout dev # &lt;- HEAD\ngit rebase main\nWhen rebasing, we are willing to rebase with copied commits onto main.\n\n\ngit checkout dev\ngit rebase main\ngit checkout main\ngit merge dev\n\n\n\n\n\n\n\n\n\n\nflowchart TB\n  C1:::commit --&gt; C0:::commit\n  C2:::commit --&gt; C1:::commit\n  C3:::commit --&gt; C1:::commit\n  C4:::commit --&gt; C3:::commit\n  main:::pointer -.-&gt; C2\n  dev:::pointer -.-&gt; C4\n  HEAD:::pointer -.-&gt; dev\n  classDef commit fill: #abc, color: #000\n  classDef pointer fill: #fff, color #000, font: #000\n\n\n\n\n\n\n\n\n\n\n\nflowchart TB\n  C1:::commit --&gt; C0:::commit\n  C2:::commit --&gt; C1:::commit\n  C3':::commit --&gt; C2:::commit\n  C4':::commit --&gt; C3':::commit\n  main:::pointer -.-&gt; C2\n  dev:::pointer -.-&gt; C4'\n  HEAD:::pointer -.-&gt; dev\n  classDef commit fill: #abc, color: #000\n  classDef pointer fill: #fff, color #000, font: #000\n\n\n\n\n\n\n\n\n\n\n\nflowchart TB\n  C1:::commit --&gt; C0:::commit\n  C2:::commit --&gt; C1:::commit\n  C3':::commit --&gt; C2:::commit\n  C4':::commit --&gt; C3':::commit\n  main:::pointer -.-&gt; C2\n  dev:::pointer -.-&gt; C4'\n  HEAD:::pointer -.-&gt; main\n  classDef commit fill: #abc, color: #000\n  classDef pointer fill: #fff, color #000, font: #000\n\n\n\n\n\n\n\n\n\n\n\nflowchart TB\n  C1:::commit --&gt; C0:::commit\n  C2:::commit --&gt; C1:::commit\n  C3':::commit --&gt; C2:::commit\n  C4':::commit --&gt; C3':::commit\n  main:::pointer -.-&gt; C4'\n  dev:::pointer -.-&gt; C4'\n  HEAD:::pointer -.-&gt; main\n  classDef commit fill: #abc, color: #000\n  classDef pointer fill: #fff, color #000, font: #000"
  },
  {
    "objectID": "posts/Git.html#git-checkout",
    "href": "posts/Git.html#git-checkout",
    "title": "Local Git Commands",
    "section": "git checkout",
    "text": "git checkout\nDidn’t we use the git checkout command without any discomfort so far? What checkout does is point HEAD to the desired object such as a branch or a commit.\ngit checkout 1b7979e16daafabf7c052411b083ea9e2e8a13d5\n\nRelative reference (^ and ~)\ngit checkout C1\ngit checkout C2^\ngit checkout main^^\ngit checkout main~2\ngit checkout HEAD^; git checkout HEAD^\n\n\n\n\n\n\n\n\n\n\nflowchart TB\n  C1:::commit --&gt; C0:::commit\n  C2:::commit --&gt; C1:::commit\n  C3:::commit --&gt; C2:::commit\n  main:::pointer -.-&gt; C3\n  HEAD:::pointer -.-&gt; main\n  classDef commit fill: #abc, color: #000\n  classDef pointer fill: #fff, color #000, font: #000\n\n\n\n\n\n\n\n\n\n\n\nflowchart TB\n  C1:::commit --&gt; C0:::commit\n  C2:::commit --&gt; C1:::commit\n  C3:::commit --&gt; C2:::commit\n  main:::pointer -.-&gt; C3\n  HEAD:::pointer -.-&gt; C1\n  classDef commit fill: #abc, color: #000\n  classDef pointer fill: #fff, color #000, font: #000\n\n\n\n\n\n\n\n\n\n\nBranch forcing (git branch -f)\nThis is called branch forcing.\ngit branch -f feature dev^\n\n\n\n\n\n\n\n\n\n\nflowchart TB\n  C1:::commit --&gt; C0:::commit\n  C2:::commit --&gt; C1:::commit\n  C3:::commit --&gt; C1:::commit\n  C4:::commit --&gt; C3:::commit\n  C5:::commit --&gt; C4:::commit\n  C6:::commit --&gt; C5:::commit\n  C7:::commit --&gt; C4:::commit\n  main:::pointer -.-&gt; C2\n  dev:::pointer -.-&gt; C6\n  feature:::pointer -.-&gt; C7\n  HEAD:::pointer -.-&gt; main\n  classDef commit fill: #abc, color: #000\n  classDef pointer fill: #fff, color #000, font: #000\n\n\n\n\n\n\n\n\n\n\n\nflowchart TB\n  C1:::commit --&gt; C0:::commit\n  C2:::commit --&gt; C1:::commit\n  C3:::commit --&gt; C1:::commit\n  C4:::commit --&gt; C3:::commit\n  C5:::commit --&gt; C4:::commit\n  C6:::commit --&gt; C5:::commit\n  main:::pointer -.-&gt; C2\n  dev:::pointer -.-&gt; C6\n  feature:::pointer -.-&gt; C5\n  HEAD:::pointer -.-&gt; main\n  classDef commit fill: #abc, color: #000\n  classDef pointer fill: #fff, color #000, font: #000"
  },
  {
    "objectID": "posts/Git.html#git-reset",
    "href": "posts/Git.html#git-reset",
    "title": "Local Git Commands",
    "section": "git reset",
    "text": "git reset\nThe reset command is often used to undo changes that have been staged or committed. This sets the HEAD to the desired commit object. The most common command will be as follows.\nUndoing the add command.\ngit reset\ngit reset HEAD\nThis command moves HEAD to the parent of the current commit (HEAD^), effectively undoing the most recent commit.\ngit reset HEAD^\nUndo a commit and make a topic branch out of it.\ngit branch topic/foo\ngit reset --hard HEAD~3\ngit checkout topic/foo"
  },
  {
    "objectID": "posts/Git.html#git-revert",
    "href": "posts/Git.html#git-revert",
    "title": "Local Git Commands",
    "section": "git revert",
    "text": "git revert\nrevert is a command that creates a new commit that undoes the changes made by a previous commit. This means that instead of deleting or altering past commits, git revert adds a new commit on top of the branch.\nWhen HEAD is on the merge commit,\ngit revert HEAD -m 1\ngit revert HEAD -m 2 \nThe number (index) of a parent can be checked with the command git cat-file -p HEAD."
  },
  {
    "objectID": "posts/CB.html",
    "href": "posts/CB.html",
    "title": "Initial Steps in Entrepreneurship",
    "section": "",
    "text": "이 항등식은 재무상태표의 대전제이다. 회계 등식이라고 한다.\n자산(Asset)은 기업이 소유하고 있는 모든 경제적 가치이다(예: 현금, 재고, 부동산 등). 이 중 부채(Liability)는 타인의 몫으로, 기업이 외부로부터 빌린 자금이나 갚아야할 의무에 해당된다(예: 대출, 미지급금 등). 자본(Equity)은 자산에서 부채를 제외한 나머지를 칭한다."
  },
  {
    "objectID": "posts/CB.html#자산-자본-부채",
    "href": "posts/CB.html#자산-자본-부채",
    "title": "Initial Steps in Entrepreneurship",
    "section": "",
    "text": "이 항등식은 재무상태표의 대전제이다. 회계 등식이라고 한다.\n자산(Asset)은 기업이 소유하고 있는 모든 경제적 가치이다(예: 현금, 재고, 부동산 등). 이 중 부채(Liability)는 타인의 몫으로, 기업이 외부로부터 빌린 자금이나 갚아야할 의무에 해당된다(예: 대출, 미지급금 등). 자본(Equity)은 자산에서 부채를 제외한 나머지를 칭한다."
  },
  {
    "objectID": "posts/CB.html#꾸짖을-책責과-빚-채債",
    "href": "posts/CB.html#꾸짖을-책責과-빚-채債",
    "title": "Initial Steps in Entrepreneurship",
    "section": "꾸짖을 책(責)과 빚 채(債)",
    "text": "꾸짖을 책(責)과 빚 채(債)\n이번 포스팅은 부채에 관한 내용이므로 ’채’자가 무엇인지 알아보자.\n꾸짖을 책(責)의 어원은 가시(龶=朿)가 돋친 돈(貝). 즉, 빚을 뜻한다1. 責자를 꾸짓다는 뜻으로 쓰이면서 빚은 인변(亻)을 붙여 債자를 쓴다2. 責은 책임(責任), 책무(責務) 등으로 쓰인다.\n직책을 달고 있다는 것은 꾸중을 도맡으면서 돈 값을 하라는 자리인 것인가ㅎㅎ."
  },
  {
    "objectID": "posts/CB.html#전환사채convertible-bond-cb",
    "href": "posts/CB.html#전환사채convertible-bond-cb",
    "title": "Initial Steps in Entrepreneurship",
    "section": "전환사채(Convertible Bond, CB)",
    "text": "전환사채(Convertible Bond, CB)\n전환사채는 일반적으로 주식회사가 투자자에게 발행하는 하나의 금융 상품이다. 해당 상품에는 발행 회사와 투자자간 중요한 계약 조건이 있는데 이것이 콜옵션과 풋옵션이다.\n\n\n\n\n\nflowchart LR\nA(주식회사) -- 전환사채증권 --&gt; B(투자자)\nB -- 납입 --&gt; A\n\n\n\n\n\n\n이로서 납입금은 회사의 자산으로 인식된다."
  },
  {
    "objectID": "posts/CB.html#call-put-option",
    "href": "posts/CB.html#call-put-option",
    "title": "Initial Steps in Entrepreneurship",
    "section": "전환사채의 콜옵션과 풋옵션",
    "text": "전환사채의 콜옵션과 풋옵션\n전환사채증권의 단위는 일반적으로 금액(예: 원, 달러 등)이다. 문서의 주요 구성 요소는 다음과 같다.\n\n발행 금액: 전환사채의 액면 금액을 명시한다.\n이자율: 예를 들어 5% 등\n만기일: 전환사채의 만기일을 명시한다. 만기일에 도달하면 사채권자(투자자)가 채권을 주식으로 전환할지 아니면 원금을 상환받을지 결정한다.\n전환가액: 전환사채를 주식으로 전환할 때 적용하는 주식 가격이다.\n부가조건\n\n부가조건들 중에 콜옵션과 풋옵션이 들어간다. 각각 발행한 회사 그리고 사채권자의 조기상환권이다."
  },
  {
    "objectID": "posts/CB.html#footnotes",
    "href": "posts/CB.html#footnotes",
    "title": "Initial Steps in Entrepreneurship",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n위키낱말사전, 꾸짖을 책(責)↩︎\n위키낱말사전, 빚 채(債)↩︎"
  },
  {
    "objectID": "posts/Kubeconfig.html",
    "href": "posts/Kubeconfig.html",
    "title": ".kube/config",
    "section": "",
    "text": "I have set up Minikube on my MacBook for an easy development environment, and at home, I have a Raspberry Pi cluster set up for my homelab. These configurations allow me to access and manage my clusters from anywhere. Specifically, I have properly configured the .kube/config file to enable remote access to the cluster at home.\nBelow is an example of the configured .kube/config file:\n\n\n.kube/config\n\n\napiVersion: v1\nclusters:\n- cluster:\n    certificate-authority-data: LS0...LS0tCg==\n    server: https://kubernetes.docker.internal:6443\n  name: docker-desktop\n- cluster:\n    insecure-skip-tls-verify: true\n    server: https://121.135.111.111:6443\n  name: raspberrypi\n- cluster:\n    certificate-authority: /Users/shane/.minikube/ca.crt\n    extensions:\n    - extension:\n        last-update: Sun, 20 Aug 2023 17:04:00 KST\n        version: v1.30.1\n        provider: minikube.sigs.k8s.io\n      name: cluster_info\n    server: https://127.0.0.1:60544\n  name: minikube\n\nThe above configuration file defines three clusters:\n\ndocker-desktop\nraspberrypi (the Raspberry Pi cluster at home, with the server address https://121.135.111.111:6443)\nminikube\n\nWith this configuration file, you can easily access various clusters using the kubectl command. For example, to access the Raspberry Pi cluster, you can use the following command:\nkubectl config use-context raspberrypi\nTo bypass the process of verifying the SSL certificate as a public certificate, use the following command:\n- cluster:\n    insecure-skip-tls-verify: true"
  },
  {
    "objectID": "posts/Entrepreneurship.html",
    "href": "posts/Entrepreneurship.html",
    "title": "Initial Steps in Entrepreneurship",
    "section": "",
    "text": "3명의 창업자가 함께 프로젝트를 진행하다가 이를 정식으로 회사로 발전시키기로 결정했다. 이들은 법인을 설립하여 프로젝트를 회사로 전환하기로 한다."
  },
  {
    "objectID": "posts/Entrepreneurship.html#법인-설립-준비",
    "href": "posts/Entrepreneurship.html#법인-설립-준비",
    "title": "Initial Steps in Entrepreneurship",
    "section": "법인 설립 준비",
    "text": "법인 설립 준비\n\n상호 및 사업 목적 결정\n\n회사의 상호와 사업 목적을 결정한다.\n\n정관 작성\n\n회사의 정관을 작성한다. 정관은 회사의 기본 규칙을 담고 있으며, 자본금, 주식, 회사 운영 방식 등을 포함한다."
  },
  {
    "objectID": "posts/Entrepreneurship.html#은행에-자본금-납입",
    "href": "posts/Entrepreneurship.html#은행에-자본금-납입",
    "title": "Initial Steps in Entrepreneurship",
    "section": "은행에 자본금 납입",
    "text": "은행에 자본금 납입\n\n자본금 납입을 위한 은행 계좌 개설\n\n법인을 설립하기 전 은행에서 발기인 명의의 임시 계좌를 개설한다. 발기인은 회사 설립을 주도하는 사람들로, 이 경우 3명의 창업자가 발기인이 된다.\n임시 계좌는 법인 설립을 위해 자본금을 입금하고 증빙하기 위한 용도로 사용된다.\n\n자본금 입금\n\n각 발기자는 자본금으로 출자하기로 한 금액을 임시 계좌에 입금한다. 예를 들어, 각각 333만 3천원씩 입금하여 총 1,000만원을 마련한다.\n이 과정에서 은행은 자본금이 제대로 입금되었는지 확인하고, 이를 증명하기 위한 자본금 납입증명서를 발급할 수 있다."
  },
  {
    "objectID": "posts/Entrepreneurship.html#법인-설립-등기",
    "href": "posts/Entrepreneurship.html#법인-설립-등기",
    "title": "Initial Steps in Entrepreneurship",
    "section": "법인 설립 등기",
    "text": "법인 설립 등기\n\n설립 등기 신청\n\n은행에서 받은 자본금 납입증명서, 정관 및 발기인들이 작성한 서류 등을 준비하여 관할 등기소에 제출한다.\n이때 설립 등기 신청서에는 회사의 기본 정보(상호, 사업 목적, 주소 등)와 자본금 납입 내역, 주식 발행 내역 등이 포함된다.\n\n법인 설립 완료\n\n등기소에서 서류 검토 후 문제가 없을 경우 법인 설립이 완료된다.\n설립 등기가 완료되면 법인이 공식적으로 설립된 것이며, 회사가 법적으로 존재하게 된다."
  },
  {
    "objectID": "posts/Entrepreneurship.html#법인-계좌로-자본금-이체",
    "href": "posts/Entrepreneurship.html#법인-계좌로-자본금-이체",
    "title": "Initial Steps in Entrepreneurship",
    "section": "법인 계좌로 자본금 이체",
    "text": "법인 계좌로 자본금 이체\n\n법인 명의의 계좌 개설\n\n설립 등기 완료 후, 법인 명의의 정식 계좌를 은행에 개설한다.\n임시 계좌에 있던 자본금을 해당 법인 계좌로 이체한다."
  },
  {
    "objectID": "posts/Entrepreneurship.html#시업자-등록",
    "href": "posts/Entrepreneurship.html#시업자-등록",
    "title": "Initial Steps in Entrepreneurship",
    "section": "시업자 등록",
    "text": "시업자 등록\n\n사업자 등록 신청\n\n법인 설립이 완료된 후, 관할 세무서에 사업자 등록을 신청한다. 이 과정에서 법인 설립 등기부 등본, 정관, 자본금 납입증명서 등을 제출한다.\n\n사업자 등록증 발급\n\n세무서에서 서류 검토 후 문제가 없을 경우 사업자 등록증을 발급받는다. 이제야 비로서 법인으로 사업을 시작할 준비가 된다."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Posts",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\n.kube/config\n\n\nwith KubeContext\n\n\n2 min\n\n\n\nK8s\n\n\n\n\n\n\n\nShane Oh\n\n\nAug 23, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAutomata Theory\n\n\nSome fun applications of discrete mathematics\n\n\n4 min\n\n\n\nMath\n\n\nDiscrete\n\n\nSet\n\n\n\n\n\n\n\nShane Oh\n\n\nJul 20, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDoom Emacs\n\n\n\n\n\n1 min\n\n\n\nEmacs\n\n\n\n\n\n\n\nShane Oh\n\n\nAug 21, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGit Prompt\n\n\nCheck the branch you are working on\n\n\n1 min\n\n\n\nGit\n\n\n\n\n\n\n\nShane Oh\n\n\nApr 18, 2023\n\n\n\n\n\n\n\n\n\n\n\n\nInitial Steps in Entrepreneurship\n\n\nCapital contribution\n\n\n2 min\n\n\n\nFinance\n\n\nEntrepreneurship\n\n\n\n\n\n\n\nShane Oh\n\n\nAug 21, 2023\n\n\n\n\n\n\n\n\n\n\n\n\nInitial Steps in Entrepreneurship\n\n\nConvertible bond\n\n\n1 min\n\n\n\nFinance\n\n\nEntrepreneurship\n\n\n\n\n\n\n\nShane Oh\n\n\nAug 21, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLocal Git Commands\n\n\nEver thought of Git graphs as linked lists?\n\n\n7 min\n\n\n\nGit\n\n\n\n\n\n\n\nShane Oh\n\n\nApr 14, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTmux\n\n\nTerminal multiplexer\n\n\n5 min\n\n\n\nLinux\n\n\nTools\n\n\n\n\n\n\n\nShane Oh\n\n\nJun 5, 2023\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Made with ♥ by Shane Oh"
  },
  {
    "objectID": "posts/Doom.html",
    "href": "posts/Doom.html",
    "title": "Doom Emacs",
    "section": "",
    "text": "Dear Mac users.\nThe official repository for doom can be found here. The Getting Started guide is a great place to begin your journey.\nThere are several ports available in emacs to help you get started. This post will cover what worked best for me."
  },
  {
    "objectID": "posts/Doom.html#installation",
    "href": "posts/Doom.html#installation",
    "title": "Doom Emacs",
    "section": "Installation",
    "text": "Installation"
  },
  {
    "objectID": "posts/GitPrompt.html",
    "href": "posts/GitPrompt.html",
    "title": "Git Prompt",
    "section": "",
    "text": "Turn this  user@host gitrepo $  into this  user@host gitrepo (main) $ .\nDownload the git-prompt.sh with the curl command.\ncurl https://raw.githubusercontent.com/git/git/master/contrib/completion/git-prompt.sh -o ~/.git-prompt.sh\nThen add the following lines in the .zshrc file.\n\n\n.zshrc\n\nsource ~/.git-prompt.sh\nsetopt PROMPT_SUBST\nPS1='%n@%m %c%F{green}$(__git_ps1 \" (%s)\")%f \\$ '"
  },
  {
    "objectID": "posts/Tmux.html",
    "href": "posts/Tmux.html",
    "title": "Tmux",
    "section": "",
    "text": "Start off with installing tmux with homebrew on Mac."
  },
  {
    "objectID": "posts/Tmux.html#intro",
    "href": "posts/Tmux.html#intro",
    "title": "Tmux",
    "section": "Intro",
    "text": "Intro\nThere are three main concepts in tmux: session, window, and pane. Start by entering tmux in the terminal.\nThe screen you see right after entering the command is a pane in a window."
  },
  {
    "objectID": "posts/Tmux.html#pane",
    "href": "posts/Tmux.html#pane",
    "title": "Tmux",
    "section": "Pane",
    "text": "Pane\nSplit the pane using Ctrl-bCtrl-b %% and Ctrl-bCtrl-b \"\".\nThe Ctrl-bCtrl-b works as a prefix to send a command — later below.\nNavigate through the panes using Ctrl-bCtrl-b ↑↑, Ctrl-bCtrl-b →→, Ctrl-bCtrl-b ↓↓, Ctrl-bCtrl-b ←←."
  },
  {
    "objectID": "posts/Tmux.html#window",
    "href": "posts/Tmux.html#window",
    "title": "Tmux",
    "section": "Window",
    "text": "Window\nOpen a new window with Ctrl-bCtrl-b cc.\nSee the windows you opened on the bottom green bar? This gives us some information about the windows in the session. The current window you are seeing is marked with an *.\nNavigate through the windows using Ctrl-bCtrl-b nn — n is for next. This will cycle through all the windows in the current session. Reverse navigate with Ctrl-bCtrl-b pp — p is for previous. You can also navigate directly to a window using the index. The bindings will be like Ctrl-bCtrl-b 11."
  },
  {
    "objectID": "posts/Tmux.html#session",
    "href": "posts/Tmux.html#session",
    "title": "Tmux",
    "section": "Session",
    "text": "Session\nFrom the very first, right after the tmux command, you are attached to a session with an auto generated index. Detach the session with the Ctrl-bCtrl-b dd command — and d is for detach. It’s almost the same as starting the bash session and detaching with the exit command. Tmux can also be detached using the exit command, but this can be tedious because each split pane needs to be closed individually with the exit command."
  },
  {
    "objectID": "posts/Tmux.html#configurations",
    "href": "posts/Tmux.html#configurations",
    "title": "Tmux",
    "section": "Configurations",
    "text": "Configurations\nFeeling comfortable with the keybindings? I hope not. The default keybindings can put significant stress on your left pinky. This brings us to the .tmux.conf file for some configuration.\n\n\n~/.tmux.conf\n\nunbind-key C-b\nset -g prefix C-a\n1bind-key C-a send-prefix\n\n2set -g mouse on\n3set -g base-index 1\nset -g renumber-windows on\nset -g default-terminal \"tmux-256color\"\n\n4bind r source-file ~/.tmux.conf \\; display-message \".tmux.conf reloaded!\"\n\n5bind '\\' split-window -h -c \"#{pane_current_path}\"\n6bind - split-window -v -c \"#{pane_current_path}\"\n\n7bind h select-pane -L\nbind j select-pane -D\nbind k select-pane -U\nbind l select-pane -R\n\n8bind x kill-pane\n9bind X kill-window\n\n\n1\n\nReplace the prefix key from Ctrl-bCtrl-b to Ctrl-aCtrl-a. When you are using a keyboard like HHKB, this will come in pretty handy. Let’s talk more about HHKB in some other posts.\n\n2\n\nPretty straight forward. Helps you navigate split panes with a mouse.\n\n3\n\nThe default is 0. For me, 0 key is a bit far for everyday use.\n\n4\n\nReload the .tmux.conf file and display a message when done — similar to something like source .bashrc.\n\n5\n\nSplit the window horizontally using the current pane’s path.\n\n6\n\nSplit the window vertically using the current pane’s path.\n\n7\n\nMove between panes using Vim-style keybindings.\n\n8\n\nKill the current pane.\n\n9\n\nKill the current window.\n\n\nPersonal preference on the following one.\n\n\n.zshrc\n\ntmux() {\n    if [ \"$#\" -eq 0 ]; then\n1        command tmux new-session -A -s default\n    else\n        command tmux \"$@\"\n    fi\n}\n\n\n1\n\nAttach a session named default when tmux is typed."
  },
  {
    "objectID": "posts/Automata.html",
    "href": "posts/Automata.html",
    "title": "Automata Theory",
    "section": "",
    "text": "Have you heard of Automata before? One of my best advisor was passionate about the subject called Automata theory.\nTake a look at this playlist by Neso Academy if you are interested. It is simply awsome.\n\n\n\n\n\n\n\n\n\ndfa\n\n\n\n\n\n\nA\n\nA\n\n\n\n-&gt;A\n\n\n\n\n\nB\n\nB\n\n\n\nA-&gt;B\n\n\n 0 \n\n\n\nC\n\nC\n\n\n\nA-&gt;C\n\n\n 1 \n\n\n\nB-&gt;A\n\n\n 0 \n\n\n\nD\n\n\nD\n\n\n\nB-&gt;D\n\n\n 1 \n\n\n\nC-&gt;A\n\n\n 1 \n\n\n\nC-&gt;D\n\n\n 0 \n\n\n\nD-&gt;B\n\n\n 1 \n\n\n\nD-&gt;C\n\n\n 0 \n\n\n\n\n\n\nFigure 1: An arbitrary Deterministic Finite Automata (DFA).\n\n\n\n\n\n\nEach circle represents a state, and the numbers marked alongside the directed arrows are inputs. In this case, A, B, C and D are the states, and the numbers 0 and 1 are the inputs.\nThe A state is the start state also represented as \\(q_0\\) (we will take a look at the notations below).\nYou can easily distinguish that the state D is different from the others by being marked with a double circle. This is called a terminal state, which represents the completion of the computation process for input sequences.\n\n\n\n\n\n\nNote\n\n\n\nThere could be multiple terminal states or no terminal states at all — which isn’t very practical, so it’s not discussed much.\nAlso, we can continue the process after reaching the terminal state, such as the example A → B → D → C → D, but we should always finish at the terminal state.\n\n\nIn Figure 1, we can see that we need a sequence length of at least 2 to reach the terminal (final; \\(F\\)) state. Moreover, in this case, the sequence length must be an even number greater than or equal to 2.\nThis is a simple example of automata, or more precisely, a Deterministic Finite Automata, DFA for short.\nThere are some classes of automata. Take a look at below.\n\n\n\n\n\nflowchart TB\nTM(Turing Machine) --&gt; FSM(FSM - Finite State Machine)\nFSM --&gt; FA(FA - Finite Automata)\nFA --&gt; FA1(FA with output)\nFA --&gt; FA2(FA without output)\nFA1 --&gt; Moore(Moore Machine)\nFA1 --&gt; Mealy(Mealy Machine)\nFA2 --&gt; DFA(DFA - Deterministic Finite Automata)\nFA2 --&gt; NFA(NFA - Non-deterministic Finite Automata)"
  },
  {
    "objectID": "posts/Automata.html#intro",
    "href": "posts/Automata.html#intro",
    "title": "Automata Theory",
    "section": "",
    "text": "Have you heard of Automata before? One of my best advisor was passionate about the subject called Automata theory.\nTake a look at this playlist by Neso Academy if you are interested. It is simply awsome.\n\n\n\n\n\n\n\n\n\ndfa\n\n\n\n\n\n\nA\n\nA\n\n\n\n-&gt;A\n\n\n\n\n\nB\n\nB\n\n\n\nA-&gt;B\n\n\n 0 \n\n\n\nC\n\nC\n\n\n\nA-&gt;C\n\n\n 1 \n\n\n\nB-&gt;A\n\n\n 0 \n\n\n\nD\n\n\nD\n\n\n\nB-&gt;D\n\n\n 1 \n\n\n\nC-&gt;A\n\n\n 1 \n\n\n\nC-&gt;D\n\n\n 0 \n\n\n\nD-&gt;B\n\n\n 1 \n\n\n\nD-&gt;C\n\n\n 0 \n\n\n\n\n\n\nFigure 1: An arbitrary Deterministic Finite Automata (DFA).\n\n\n\n\n\n\nEach circle represents a state, and the numbers marked alongside the directed arrows are inputs. In this case, A, B, C and D are the states, and the numbers 0 and 1 are the inputs.\nThe A state is the start state also represented as \\(q_0\\) (we will take a look at the notations below).\nYou can easily distinguish that the state D is different from the others by being marked with a double circle. This is called a terminal state, which represents the completion of the computation process for input sequences.\n\n\n\n\n\n\nNote\n\n\n\nThere could be multiple terminal states or no terminal states at all — which isn’t very practical, so it’s not discussed much.\nAlso, we can continue the process after reaching the terminal state, such as the example A → B → D → C → D, but we should always finish at the terminal state.\n\n\nIn Figure 1, we can see that we need a sequence length of at least 2 to reach the terminal (final; \\(F\\)) state. Moreover, in this case, the sequence length must be an even number greater than or equal to 2.\nThis is a simple example of automata, or more precisely, a Deterministic Finite Automata, DFA for short.\nThere are some classes of automata. Take a look at below.\n\n\n\n\n\nflowchart TB\nTM(Turing Machine) --&gt; FSM(FSM - Finite State Machine)\nFSM --&gt; FA(FA - Finite Automata)\nFA --&gt; FA1(FA with output)\nFA --&gt; FA2(FA without output)\nFA1 --&gt; Moore(Moore Machine)\nFA1 --&gt; Mealy(Mealy Machine)\nFA2 --&gt; DFA(DFA - Deterministic Finite Automata)\nFA2 --&gt; NFA(NFA - Non-deterministic Finite Automata)"
  },
  {
    "objectID": "posts/Automata.html#notations",
    "href": "posts/Automata.html#notations",
    "title": "Automata Theory",
    "section": "Notations",
    "text": "Notations\nTo cover up all of those classes, we need a formal definition of automation.\n\nAutomation\n\\[\nM = \\langle \\Sigma, \\Gamma, Q, \\delta, \\lambda \\rangle\n\\]\n\n\\(\\Sigma\\) is a finite set of symbols, called the input alphabet of the automation.\n\\(\\Gamma\\) is another finite set of symbols, called the output alphabet of the automation.\n\\(Q\\) is a set of states.\n\\(\\delta\\) is the next-state function \\(\\delta : Q \\times \\Sigma \\to Q\\)\n\\(\\lambda\\) is the next-output function \\(\\lambda : Q \\times \\Sigma \\to \\Gamma\\)\n\n\n\n\n\n\n\nNote\n\n\n\nIf \\(Q\\) (set of states) is finite, then \\(M\\) is finite automation.\n\n\nWhen we take a look at the automation without output, the output \\(\\Gamma\\) and \\(\\lambda\\) doesn’t do much. Instead we try to understand the automation without output as in terms of automation as an acceptor to see if the automation can accept a certain language or not.\nWhen we look at an automaton without output, the output alphabet (\\(\\Gamma\\)) and the output function (\\(\\lambda\\)) don’t play a significant role. Instead, we try to understand the automaton without output in terms of an automaton as an acceptor, to see if it can accept a certain language or not.\nThe notation below will be more useful.\n\n\nAutomation as an Acceptor\n\\[\nM = \\langle \\Sigma, q_0, Q, \\delta, F \\rangle\n\\]\n\n\\(q_0 \\in Q\\) is a start state\n\\(F \\subseteq Q\\) is called final states or accept state. Notice that \\(F\\) is a set, which means there could be none, one or multiple final states.\n\nTake an example with Figure 1 as an acceptor.\n\n\\(\\Sigma = \\lbrace 0, 1 \\rbrace\\)\n\\(q_0 = A\\)\n\\(Q = \\lbrace A, B, C, D \\rbrace\\)\n\\(F = \\lbrace F \\rbrace\\)"
  }
]